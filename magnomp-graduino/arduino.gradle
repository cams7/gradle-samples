import com.sun.jna.platform.win32.Kernel32;
import java.io.ByteArrayOutputStream;
import java.io.StringReader;
import java.io.BufferedReader;
import java.text.SimpleDateFormat;
import java.util.Locale;

apply from: 'properties.gradle'

ext.arduinoCore = "$arduinoDir\\hardware\\arduino\\cores\\arduino\\"
ext.arduinioVarianStandard = "$arduinoDir\\hardware\\arduino\\variants\\standard\\"
ext.shortBuildDir = short_path(buildDir.absolutePath)
ext.librariesDir = "$arduinoDir\\libraries\\"

buildscript {
  repositories {
    mavenCentral()
  }

  dependencies {
    classpath 'net.java.dev.jna:jna:3.4.0' 
    classpath 'net.java.dev.jna:platform:3.4.0' 
  }
}

class StreamGobbler extends Thread {
  BufferedInputStream source;
  BufferedOutputStream dest;

  StreamGobbler(InputStream source, OutputStream dest) {
    this.source = new BufferedInputStream(source);
    this.dest = new BufferedOutputStream(dest);
  }

  public void run() {
    try {           
      byte[] b = new byte[100]
      int size = 0;
      while ((size = source.read(b)) > 0)
        dest.write(b, 0, size)

      dest.flush()
    } catch (IOException ioe) {
      ioe.printStackTrace();
    }
  }
}

def extract_archive_index() {
  def result = [:]
  
  def index = new File(buildDir, "archiveindex.dat")

  if (index.exists()) {
    def reader = index.newReader()
    String line = null
    while ((line = reader.readLine()) != null) {
      def elems = line.split("=", 2)
      result[elems[0]] = Long.parseLong(elems[1])
    }
  }

  return result
}

def save_archive_index(index) {
  def index_file = new File(buildDir, "archiveindex.dat").newPrintWriter()
  index.each {
    index_file.println("${it.key}=${it.value}")
  }
  index_file.flush()
  index_file.close()
}

def exec_cmd(cmd) {
  def verbose = project.hasProperty("verbose")

  def command = ""

  def str_cmd = []
  cmd.each {
    command = command + it + " "
    str_cmd << it.toString()
  }

  if (verbose)
    println command

  def redir_out = verbose?System.out:new ByteArrayOutputStream()

  def pb = new ProcessBuilder(str_cmd)
  pb.redirectErrorStream(true)
  pb.directory(projectDir)
  def proc = pb.start()
  new StreamGobbler(proc.getInputStream(), redir_out).start()
  def retCode = proc.waitFor()
  if (retCode != 0) {
    if (!verbose) {
      println command
      System.out.print(new String(redir_out.toByteArray()))
    }
    throw new GradleException()
  }
}

def short_path(file) {
  char[] output = new char[500];
  def size = Kernel32.INSTANCE.GetShortPathName(file, output, output.length)
  return new String(output, 0, size)
}

def archive_object_file(object_file) {
  def cmd = ["$arduinoDir\\hardware\\tools\\avr\\bin\\avr-ar",
         "rcs",
         "$buildDir\\core.a",
         short_path(object_file.parent) + "\\" + object_file.name]

  exec_cmd(cmd)
}

def enum_source_files(list, dir) {
    dir.eachFileMatch(~/.*\.c/) {
      list << it
    }

    dir.eachFileMatch(~/.*\.cpp/) {
      list << it
    }

    dir.eachDirRecurse() {
      enum_source_files(list, it)
    }
}

def build_file(file, libraries) {
  def object_file = new File(buildDir, file.name + ".o")

  if (file.lastModified() < object_file.lastModified())
    return object_file

  // File.absolutePath doesn't work if the file doesn't exist
  object_file.createNewFile()

  println "Compiling ${file.name}"

  boolean cpp = file.getPath() =~ /.*\.cpp/

  def noexceptions = cpp?"-fno-exceptions":""
  def compiler = cpp?"avr-g++":"avr-gcc";


  def cmd = []
  cmd << "$arduinoDir\\hardware\\tools\\avr\\bin\\$compiler"
  cmd << "-c"
  cmd << "-g"
  cmd << "-Os"
  cmd << "-Wall"
  cmd << "$noexceptions"
  cmd << "-ffunction-sections"
  cmd << "-fdata-sections"
  cmd << "-mmcu=$cpuName"
  cmd << "-DF_CPU=$cpuClock"
  cmd << "-DARDUINO=100"
  cmd << "-I${short_path(arduinoCore)}"
  cmd << "-I${short_path(arduinioVarianStandard)}"
  libraries.each { library ->
    cmd << "-I${short_path(library.absolutePath)}"
    library.eachDirRecurse() {
      if (!it.absolutePath.contains("\\examples\\"))
        cmd << "-I${short_path(it.absolutePath)}"
    }
  }
  cmd << "${short_path(file.getAbsolutePath())}"
  cmd << "-o" + short_path(object_file.parent) + "\\" + object_file.name

  exec_cmd(cmd)

  return object_file
}

def link(sketch_object_files) {
  def cmd = []
  cmd << "$arduinoDir\\hardware\\tools\\avr\\bin\\avr-gcc"
  cmd << "-Os"
  cmd << "-Wl"
  cmd << "--gc-sections"
  cmd << "-mmcu=$cpuName"
  cmd << "-o$shortBuildDir\\${sketchMainFile}.elf"
  sketch_object_files.each {
    cmd << short_path(it.absolutePath)
  }
  cmd << short_path(buildDir.absolutePath) + "\\core.a"
  cmd << "-L$shortBuildDir"
  cmd << "-lm"
  exec_cmd(cmd)
}

def objcopy() {
  def cmd = ["$arduinoDir\\hardware\\tools\\avr\\bin\\avr-objcopy",
         "-O",
         "ihex",
         "-j",
         ".eeprom",
         "--set-section-flags=.eeprom=alloc,load",
         "--no-change-warnings",
         "--change-section-lma",
         ".eeprom=0",
         "$buildDir\\${sketchMainFile}.elf",
         "$buildDir\\${sketchMainFile}.eep"]
  exec_cmd(cmd)

  cmd = ["$arduinoDir\\hardware\\tools\\avr\\bin\\avr-objcopy",
         "-O",
         "ihex",
         "-R",
         ".eeprom",
         "$buildDir\\${sketchMainFile}.elf",
         "$buildDir\\${sketchMainFile}.hex"]
  exec_cmd(cmd)
}

def can_skip_archive(index, arduino_object_files) {
  def result = true
  arduino_object_files.each { obj ->
    if (!index.containsKey(obj.name))
      result = false
    else if (obj.lastModified() > index[obj.name])
      result = false
  }

  return result
}

def enum_includes(file) {
  def result = []
  def reader = file.newReader()
  def line = null
  // Pattern copied from Arduino IDE source code: processing.app.preproc.PdePreprocessor.java
  def include_pattern = ~/^\s*#include\s+[<"](\S+)[">]/
  while ((line = reader.readLine()) != null) {
    def matcher = include_pattern.matcher(line)
    if (matcher.matches()) {
      def header = matcher[0][1]
      if (header.endsWith(".h"))
        header = header.substring(0, header.length() -2)
      result << header
    }
      
  }  

  return result;
}

task build << {
    buildDir.mkdirs()
    def sketch_files = []
    def arduino_files = []
    def sketch_object_files = []
    def arduino_object_files = []   
    def libraries = []
    enum_source_files(sketch_files, projectDir)
    enum_source_files(arduino_files, new File(arduinoCore))  

    def includes = enum_includes(new File(projectDir, sketchMainFile))
    includes.each { include ->
      def libdir = new File(librariesDir, include)
      if (libdir.exists() && libdir.isDirectory()) {
        libraries << libdir
        enum_source_files(arduino_files, libdir)
      }
    }

    println "Compiling source files"
    sketch_files.each {
      sketch_object_files << build_file(it, libraries)
    }

    arduino_files.each {
      arduino_object_files << build_file(it, libraries)
    }

    def archive_index = extract_archive_index()
    if (!can_skip_archive(archive_index, arduino_object_files)) {
      println "Archiving object files"
      archive_index.clear()
      arduino_object_files.each {
        archive_object_file(it)
        archive_index[it.name] = it.lastModified()
      }
      save_archive_index(archive_index)
    }

    println "Linking"
    link(sketch_object_files)

    objcopy()
}

task upload(dependsOn: build) << {
  def cmd = ["$arduinoDir\\hardware\\tools\\avr\\bin\\avrdude",
         "-C$arduinoDir\\hardware\\tools\\avr\\etc\\avrdude.conf",
         "-v",
         "-v",
         "-v",
         "-v",
         "-p$cpuName",
         "-carduino",
         "-P\\\\.\\$comPort",
         "-b115200",
         "-D",
         "-Uflash:w:$shortBuildDir\\${sketchMainFile}.hex:i"]
  exec_cmd(cmd)
}

task clean << {
  ant.delete(dir: buildDir)
}